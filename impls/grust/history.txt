#V2
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(fn* a (+ 1 2))
(a 3 4)
(def! d 9)
d
(fn* a (+ 1 2))
(+ 1 2)
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(+ 1 2)
(def! d 9)
d
(def! d 9)
d
(def! d 9)
d
(+ 1 2)
(def! d 9)
d
(def! d 9)
d
(fn* (a) a)
( (fn* (a) a) 7)
(+ 1 2)
(list)
(if (> (count (list 1 2 3)) 3) 89 78)
(do (prn 101))
(str "\\\\"")
 (str "")
(load-file "../tests/incA.mal")
(inc4 3)
(def! a (atom 2))
(def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\\nnil)")))))
(load-file "../tests/computations.mal")
(load-file "../tests/inc.mal")
(slurp "../tests/computations.mal"
(slurp "../tests/computations.mal")
(do (slurp "../tests/computations.mal"))
(str (do (slurp "../tests/computations.mal")))
(str "(do "(slurp "../tests/computations.mal") "\\nnil)")
(eval (str "(do "(slurp "../tests/computations.mal") "\\nnil)"))
(eval (read-string (str "(do "(slurp "../tests/computations.mal") "\\nnil)")))
(read-string (str "(do "(slurp "../tests/computations.mal") "\\nnil)"))
(def! atm (atom 9))
atm
(deref atm)
@atm
(def! atm (atom 9))
(deref atm)
@atm
(def! atm (atom 9))
@atm
not
load-file
cond
(try* abc (catch* exc (prn "exc is:" exc)))
(assoc (hm "a" 1 "b" 3))
(def! hm3 (assoc hm2 "b" 2))
(def! hm1 (hash-map))
(assoc hm1 "d" 4)
hm1
(def! hm1 (hash-map))
(def! hm2 (assoc hm1 "a" 1))
hm2
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
hm4
(dissoc hm4 "a")
*host-language*
^{"a" 1} [1 2 3]
(def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:uter (first args)} (rest args))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {"outer" (first args)} (rest args))))))
(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))
:a
{  :a  {:b   {  :cde     3   }  }}
